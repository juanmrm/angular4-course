Sirve para simular la navegaci칩n de cara al usuario entre distintas p치ginas.

No podemos navegar poniendo por ejemplo <a href="/users">Users</a> porque esto recarga nuestra aplicacion y perdemos el estado.

In the app.module

-- Imports

    import { Routes, RouterModule } from '@angular/router';

-- Defining the routes

    const appRoutes: Routes = [
      { path: '', component: HomeComponent },
      { path: 'users', component: UsersComponent },
      { path: 'servers', component: ServerComponent }
    ]

-- Register the routing configuration in imports

    RouterModule.forRoot(appRoutes)

-- In the template, mark the place for inserting the component

    <router-outlet></router-outlet>

    For routing in the templates we use
      routerLink="/desired-route"
        or
      [routerLink] = "['/desired-route']"

    Las rutas que empiezan por / son rutas absolutas, sino se interpretan como rutas relativas
    Tambien seria relativa ./desired-route y tambien podemos hacer ../../desired-route (subimos 2 niveles y navegamos a desired-route)

-- Styling active router links:

  routerLinkActive="css-class"
      Se usa para que el router de Angular a침ada el estilo automaticamente si esta activa la ruta, esto es si el path actual contiene / forma
        parte de nuestra ruta.

  [routerLinkActiveOptions]="{exact: true} Only add this css active class if the path match exactly

-- Load a route programatically:

    import { Router, ActivatedRoute } from '@angular/router';

    constructor(private router: Router, private route: ActivatedRoute) { }

    this.router.navigate(['servers']) // Esta ruta sera relativa al raiz /

    this.router.navigate(['servers'], {relativeTo: this.route}); //Esta ruta sera relativa a la ruta actual de navegacion que la tenemos como valor en this.route

-- Passing parameters to routes - dinamic paths:

  En las rutas podemos definir: { path: 'users/:id/:name', component: UserComponent }, // Aqui el id o el name son parametros

-- Fetching route parameters in components:

      ngOnInit() {
        this.user = {
          id: this.route.snapshot.params['id'],  // Using the snapshot -> only valid for one time.
          name: this.route.snapshot.params['name']
        };

  -- Fetching Reactively with Route  Observable:

        import { ActivatedRoute, Params} from '@angular/router';

        this.route.params
            .subscribe(
              (params: Params) => {
                this.user.id = params['id'];
                this.user.name = params['name'];
              }
            );

    -- Important note about Observables

      Con los observables de angular que son del framework no necesitamos hacer el unsubscribe.
      Con los nuestro deberiamos de hacer

      import { Subscription } from 'rxjs/Subscription';

      Implentar OnDestroy:

      ngOnDestroy() {
        this.xxxxSubscription.unsubscribe();
      }

    -- Passing Query Parameters (?param=value) and Fragments (#) Template and Programatically

      In the template:

        p.e: Construye una url /servers/5/edit/?allowEdit=1#loading

        <a
          [routerLink]="['/servers', 5, 'edit']"
          [queryParams]="{allowEdit: '1'}"
          fragment="loading" // Tb valdria [fragment] = "'loading'"
          href="#">
          {{ server.name }}
        </a>

      Programatically:

        this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});

    -- Retrieving Query Params and Fragments:

      Acceder al snapshot:
        console.log(this.route.snapshot.queryParams);
        console.log(this.route.snapshot.fragment);

      Con Observables:
        this.route.queryParams.subscribe();
        this.route.fragment.subscribe();

    -- Setting up Child Nested Routes:

        Usamos la propiedad children al definir las rutas.

        { path: 'servers', component: ServersComponent, children: [
            { path: ':id', component: ServerComponent },
            { path: ':id/edit', component: EditServerComponent }
          ] }

        En el template html tendremos que a침adir donde antes teniamos por ejemplo el <app-edit-server></app-edit-server>

        <router-outlet><router-outlet> para que incorpore el nested element.

    -- Configuring the Handling of Query Parameters: queryParamsHandling property when navigate

           this.router.navigate(['edit'], { relativeTo: this.route, queryParamsHandling: 'preserve' }); //Merge, Preserve...

    -- Redirecting and Wildcard Routes:

        const appRoutes: Routes = [
          { path: 'not-found', component: PageNotFoundComponent },
          { path: '**', redirectTo: '/not-found'} //Tiene que ser la ultima ruta que configuramos porque sino iriamos siempre a not-found component
        ]

        La estrategia por defecto para el macheo de URLs es "prefix", es decir que si el path comienza por la ruta puesta...
        Si queremos cambiar el comportamiento para que sea un macheo exacto hay que cambiar la estrategia a "full"
            p.e: { path: '', redirectTo: '/somewhere-else', pathMatch: 'full' }

    -- Outsourcing the Route Configuration

        In app.module.ts:
            import our module AppRoutingModule

        Define our routing module:

        const appRoutes: Routes = [
          { path: '', component: HomeComponent },
          { path: 'users', component: UsersComponent, children: [
            { path: ':id/:name', component: UserComponent },
          ] },
          { path: 'not-found', component: PageNotFoundComponent },
          { path: '**', redirectTo: '/not-found'}
        ]

        @NgModule({
          imports: [
            RouterModule.forRoot(appRoutes)
          ],
          exports: [
            RouterModule
          ]
        })
        export class AppRoutingModule { }

    -- Route Guards: control de acceso para las rutas, padre e hijos

        En el routing las protegemos con canActivate y canActivateChild:
            { path: 'servers',
                // canActivate: [AuthGuard],
                canActivateChild: [AuthGuard],
                component: ServersComponent,
                children: [
                { path: ':id', component: ServerComponent },
                { path: ':id/edit', component: EditServerComponent }
              ] }

        Definimos el servicio AuthGuard encargado de gestionar el control de acceso.

            @Injectable()
            export class AuthGuard implements  CanActivate, CanActivateChild {

              constructor(private authService: AuthService, private router: Router) {}

              //Puede funcionar asincronamente (retornando Observable o Promise) o sincronamente.
              canActivate(route: ActivatedRouteSnapshot,
                          state: RouterStateSnapshot,): Observable<boolean> | Promise<boolean> | boolean {

                return this.authService.isAuthenticated()
                  .then(
                    (authenciated: boolean) => {
                      if(authenciated) {
                        return true
                      } else {
                        this.router.navigate(['/']);
                      }
                    }
                  );
              }

              canActivateChild(route: ActivatedRouteSnapshot,
                               state: RouterStateSnapshot,): Observable<boolean> | Promise<boolean> | boolean {

                return this.canActivate(route, state);
              }

             // Servicio de apoyo para gestionar el login
              export class AuthService {
                loggedIn = false;

                isAuthenticated() {
                  const promise = new Promise(
                    (resolve, reject) => {
                      setTimeout(() => {
                        resolve(this.loggedIn)
                      }, 800)
                    }
                  )
                  return promise;
                }

                login() {
                  this.loggedIn = true;
                }

                logout() {
                  this.loggedIn = false;
                }

              }

    -- Controlling navigation with canDeactivate: controlar si se puede abandonar una ruta estando en el estado actual.

        En la ruta:
            { path: ':id/edit', component: EditServerComponent, canDeactivate: [CanDeactivateGuard] }

        Definimos una interfaz / servicio

            export interface CanComponentDeactivate {

              canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
            }

            export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {

              // This will be called by the Angular Router
              canDeactivate(component: CanComponentDeactivate,
                            currentRoute: ActivatedRouteSnapshot,
                            currentState: RouterStateSnapshot,
                            nextState?: RouterStateSnapshot): Observable<boolean> | Promise<boolean> |
                boolean {
                  return component.canDeactivate();
                }
            }

        En nuestro componente implementamos CanComponentDeactivate



