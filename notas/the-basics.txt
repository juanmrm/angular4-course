SPA el server solo nos sirve 1 pagina que es el index.html

En index.html tenemos el app-root, no es una tag html, es un componente que ha sido generado por el CLI de Angular
y lo tenemos en src/app. En el app.component.ts tenemos la definicion (selector, template y styleUrls)

En el index.html final que nos proporciona el servidor se han incluido scripts que estan importados.

El primer codigo que se ejecuta es el que esta en main.ts
  platformBrowserDynamic().bootstrapModule(AppModule); // Start AppModule

index.html
  -> scripts in body
    -> main.ts (platformBrowserDynamic().bootstrapModule(AppModule);)
      -> app.module.ts (bootstrap: [AppComponent], indicamos la lista de componentes que debe conocer Angular cuando analiza el index.html)
        -> app.component.ts -> con esto index.html sabe como interpretar el app-root que aparecia

---------Modulos -----------

  Angular utiliza los componentes para contruir las paginas web
  Los modulos sirven para empaquetar / agrupar diferentes piezas, por ejemplo Components en paquetes (packages).

  @NgModule({ //Decorator, como lo es por ejemplo @Component
    declarations: [ //Registramos los componentes de nuestra App y añadiremos el import correspondiente
      AppComponent
    ],
    imports: [ //importaciones de otros modulos que necesitemos
      BrowserModule,
      FormsModule,
      HttpModule
    ],
    providers: [],
    bootstrap: [AppComponent] //Le indica a Angular que componente tiene que reconocer cuando arranca la aplicacion, al analizar index.html
  })
  export class AppModule { }

------- Componentes --------

  Cada uno cuenta con su template, sus estilos, su lógica etc...

  AppComponent definido en app.component.ts es un componente especial (es el pricipal, root component)

  El resto de componentes se iran añadiendo en  app.component.html NO en el index.html

  import { Component } from '@angular/core';

    @Component({
      selector: 'app-server',
      templateUrl: './server.component.html'
    })
    export class ServerComponent {}

-------- Crear Components usando el CLI -------

ng generate component servers -> ng g c servers (es una abreviatura)

ng g c /recipes/recipes-list --spec false (creando el componente dentro de la carpeta recipes y ademas sin test)

-------- Styles for Components ---------

  - Por ejemplo usando clases de bootstrap en los html de los componentes
  - En el fichero xxxx.component.css
  - En el xxxx.component.ts Inline

------- Databinding 4 formas (properties and events binding)--------
  String Interpolation
  Property Binding
  Event binding
  Two Way databinding

  - String Interpolation:
    {{ expression }} //expression debe retornar un String o un objeto que JS pase a String, puede ser un metodo, un texto, una propiedad etc...
    p.e: {{ 'Server' }}, {{ serverId }}, {{ getServerStatus() }}, <p> {{ allowNewServer }} </p>

  - Property Binding: binding de expresiones de typescript / javascript con atributos de los tags HTML
    <button type="button" [disabled] = "!allowNewServer">Add Server</button>
    <p [innerText] = "allowNewServer"></p>

  - Event binding: incorporar a los controles HTML funcionalidad de nuestro codigo
    p.e : para el evento onclick del botón
      <button (click)="onCreateServer()">Add Server</button>

  - NOTE: How do you know to which Properties or Events of HTML Elements you may bind?
    You can basically bind to all Properties and Events - a good idea is to console.log() the element you're interested in
    to see which properties and events it offers.
      p.e: var result = document.getElementsByTagName("p"); //recuperamos todos los p's del documento HTML y hacemos
        console.log(result) para explorarlos

  - Passing and using data with event binding:
    <input type="text" (input)="onUpdateServerName($event)"> //Con $event le estamos pasando el evento que se genera a nuestro metodo

    //En nuestro metodo
    onUpdateServerName(event: Event) {
      //console.log(event);
      this.serverName = (<HTMLInputElement>event.target).value; //Casting of the element to HTMLInputElement
    }

  - Two Way databinding (Important: FormsModule is Required for Two-Way-Binding).
      Requisitos:
        - Adding the FormsModule  to the imports[] array in the AppModule (app.module.ts).
        - import { FormsModule } from '@angular/forms';


    Binding in two directions. Una forma sencilla de reaccionar a eventos en las 2 direcciones.
    Aqui si escribimos en el input se va actualizando el texto, pero si en otra parte se actualiza la variable serverName, nuestro
    input va a reflejar tambien los cambios automaticamente.
    p.e: <input type="text" class="form-control" [(ngModel)]="serverName">

  -------------------- Directives -------------------------------

    Las directivas con instrucciones en el DOM.

    Los componentes que creamos al final funcionan como directivas, pero tambien hay built-in directives y podemos definir las nuestras.

    Built-in directives:

    Structural Directives (empiezan por *): cambian el DOM añadiendo / borrando elementos. No son elementos hidden.
      - *ngIf: conditional if. Podemos añadir un else y usar otra directiva.
        p.e: <p *ngIf="serverCreated; else noServer">Server was created. My server name is {{ serverName }}</p>
      <ng-template #noServer>
        <p>No server was created!</p>
      </ng-template

      - *ngFor: repeating an element (tracking the index in i)
        p.e: <app-server *ngFor="let server of servers; let i=index" ></app-server>

    Attribute Directives: no añaden / borran elementos. Solo cambian el estado del elemento donde se pone la directiva.
      - ngStyle: cambiar los estilos dinamicos
        p.e: <p [ngStyle]="{backgroundColor: getColor()}">{{ 'Server' }} with ID {{ serverId }} is {{ getServerStatus() }}</p>
                            //Dentro de {} ponemos typescript expressions

      -ngClass: añadir o quitar clases de estilos dinamicamente.
        p.e: [ngClass]="{online: serverStatus === 'online'}">{{ 'Server' }} with ID {{ serverId }} is {{ getServerStatus() }}

    -------------------- Custom property Binding--------------------

    Por defecto las properties de los componentes sólo son accesibles dentro de estos componentes, no son accesibles desde fuera de los
    mismos.

    Si queremos que una propiedad de nuestro componente sea accesible por otros componentes padres, tenemos que anotarlo asi.
      import Input from '@angular/core';
      @Input('srvElement') element: { type: string, name: string, content: string }; //Podemos indicar un alias con el que exponemos hacia afuera.

    -------------------- Binding to custom events ------------------
      Se trata de emitir eventos que contienen informacion requerida por otro componente.

      p.e:
        En app.component.html:
          <app-cockpit
            (serverCreated) = "onServerAdded($event)">
          </app-cockpit>

        En app.component.ts:
          onServerAdded(serverData: {serverName: string, serverContent: string}) {
            this.serverElements.push({
              type: 'server',
              name: serverData.serverName,
              content: serverData.serverContent
              });
            }

        En cockpit.component.ts:
          @Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();

          onAddServer() {
            this.serverCreated.emit({
              serverName: this.newServerName,
              serverContent: this.newServerContent
            });
          }
